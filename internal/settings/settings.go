package settings

import (
	"errors"
	"io"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
)

const (
	FileExtension = ".grundy.ini"
	ExampleSuffix = "-example"

	defaultFileMode = 0644

	managedFileComment = "[WARNING] DO NOT EDIT THIS FILE. This file is managed by the application."

	none            section = ""
	appSettings     section = "settings"
	gameCollections section = "game_collections"

	launcherExePath          key = "exe_path"
	launcherDefaultArgs      key = "default_args"
	launcherGameFileSuffixes key = "game_file_suffixes"

	gameName           key = "name"
	gameExeSubPath     key = "exe"
	gameOverrideArgs   key = "override_args"
	gameAdditionalArgs key = "additional_args"
	gameIconPath       key = "icon"
	gameCategories     key = "categories"
	gameTilePath       key = "tile"

	listSeparator  = ","
	gameIconPrefix = "-icon"
	gameTilePrefix = "-tile"
)

var (
	GameIconSuffixes = []string{gameIconPrefix + ".png", gameIconPrefix + ".jpg"}
	GameTileSuffixes = []string{gameTilePrefix + ".png", gameTilePrefix + ".jpg"}
)

type section string

func (o section) string() string {
	return string(o)
}

type key string

func (o key) string() string {
	return string(o)
}

type DynamicFilePath interface {
	FilePath() string
	WasDynamicallySelected() bool
	FileExists() bool
}

type defaultDynamicFilePath struct {
	filePath   string
	dynamic    bool
	fileExists bool
}

func (o defaultDynamicFilePath) FilePath() string {
	return o.filePath
}

func (o defaultDynamicFilePath) WasDynamicallySelected() bool {
	return o.dynamic
}

func (o defaultDynamicFilePath) FileExists() bool {
	return o.fileExists
}

type SaveableSettings interface {
	Filename(additionalSuffix string) string
	Reload(filePath string) error
	Save(io.Writer) error
	ResetToDefaults()
	Example() SaveableSettings
}

type AppSettings interface {
	SaveableSettings
	GameCollectionsPathsToLauncherNames() map[string]string
	AddGameCollection(dirPath string, launcherName string)
	RemoveGameCollection(dirPath string)
	HasGameCollection(dirPath string) (launcherName string, ok bool)
}

type defaultAppSettings struct {
	config configFile
}

func (o *defaultAppSettings) Filename(additionalSuffix string) string {
	return "app" + additionalSuffix + FileExtension
}

func (o *defaultAppSettings) Reload(filePath string) error {
	return o.config.Reload(filePath)
}

func (o *defaultAppSettings) Save(w io.Writer) error {
	return o.config.Save(w)
}

func (o *defaultAppSettings) ResetToDefaults() {
	o.config.Clear()

	o.config.AddSection(appSettings)
	o.config.DeleteSection(gameCollections)
	o.config.AddSection(gameCollections)
}

func (o *defaultAppSettings) Example() SaveableSettings {
	return NewAppSettings()
}

func (o *defaultAppSettings) GameCollectionsPathsToLauncherNames() map[string]string {
	return o.config.SectionKeysToValues(gameCollections)
}

func (o *defaultAppSettings) AddGameCollection(dirPath string, launcherName string) {
	o.config.AddOrUpdateKeyValue(gameCollections, key(dirPath), launcherName)
}

func (o *defaultAppSettings) RemoveGameCollection(dirPath string) {
	o.config.DeleteKey(gameCollections, key(dirPath))
}

func (o *defaultAppSettings) HasGameCollection(dirPath string) (string, bool) {
	if !o.config.HasKey(gameCollections, key(dirPath)) {
		return "", false
	}

	return o.config.KeyValue(gameCollections, key(dirPath)), true
}

type LaunchersSettings interface {
	SaveableSettings
	Has(name string) (Launcher, bool)
	AddOrUpdate(Launcher)
	Remove(Launcher)
}

// TODO: Locking.
type defaultLaunchersSettings struct {
	config configFile
}

func (o *defaultLaunchersSettings) Filename(additionalSuffix string) string {
	return "launchers" + additionalSuffix + FileExtension
}

func (o *defaultLaunchersSettings) Reload(filePath string) error {
	return o.config.Reload(filePath)
}

func (o *defaultLaunchersSettings) Save(w io.Writer) error {
	return o.config.Save(w)
}

func (o *defaultLaunchersSettings) ResetToDefaults() {
	o.config.Clear()
}

func (o *defaultLaunchersSettings) Example() SaveableSettings {
	s := NewLaunchersSettings()

	s.AddOrUpdate(NewLauncher().Example())

	return s
}

func (o *defaultLaunchersSettings) Has(name string) (Launcher, bool) {
	l := NewLauncher()

	sec := section(name)

	if o.config.HasSection(sec) {
		l.SetName(name)
		l.SetExePath(o.config.KeyValue(sec, launcherExePath))
		l.SetDefaultArgs(o.config.KeyValue(sec, launcherDefaultArgs))
		suffixes := o.config.KeyValue(sec, launcherGameFileSuffixes)
		if len(suffixes) > 0 {
			l.SetGameFileSuffixes(strings.Split(suffixes, listSeparator))
		}

		return l, true
	}

	return l, false
}

func (o *defaultLaunchersSettings) AddOrUpdate(l Launcher) {
	sec := section(l.Name())

	o.config.AddOrUpdateKeyValue(sec, launcherExePath, l.ExePath())
	o.config.AddOrUpdateKeyValue(sec, launcherDefaultArgs, l.DefaultArgs())
	o.config.AddOrUpdateKeyValue(sec, launcherGameFileSuffixes, strings.Join(l.GameFileSuffixes(), listSeparator))
}

func (o *defaultLaunchersSettings) Remove(l Launcher) {
	o.config.DeleteSection(section(l.Name()))
}

type Launcher interface {
	ResetToDefaults()
	Example() Launcher
	IsValid() error
	SetName(string)
	Name() string
	SetExePath(string)
	ExePath() string
	ExeDirPath() string
	SetDefaultArgs(string)
	DefaultArgs() string
	SetGameFileSuffixes([]string)
	GameFileSuffixes() []string
}

type defaultLauncherSettings struct {
	name             string
	exePath          string
	defaultArgs      string
	gameFileSuffixes []string
}

func (o *defaultLauncherSettings) ResetToDefaults() {
	o.name = ""
	o.exePath = ""
	o.gameFileSuffixes = []string{}
	o.defaultArgs = ""
}

func (o *defaultLauncherSettings) Example() Launcher {
	launcher := NewLauncher()

	launcher.SetName("example-launcher")

	if runtime.GOOS == "windows" {
		launcher.SetExePath("C:\\path\\to\\launcher\\executable.file")
		launcher.SetGameFileSuffixes([]string{".exe", ".bat"})
	} else {
		launcher.SetExePath("/path/to/launcher/executable.file")
		launcher.SetGameFileSuffixes([]string{".sh", ".bin"})
	}

	launcher.SetDefaultArgs("")

	return launcher
}

func (o *defaultLauncherSettings) IsValid() error {
	if len(o.name) == 0 {
		return errors.New("Missing name field")
	}

	if len(o.exePath) == 0 {
		return errors.New("The '" + launcherExePath.string() + "' field is missing or is empty")
	}

	_, err := os.Stat(o.exePath)
	if err != nil {
		return errors.New("Executable does not exist - " + err.Error())
	}

	if len(o.gameFileSuffixes) == 0 {
		return errors.New("The '" + launcherGameFileSuffixes.string() + "' field is missing or is empty")
	}

	return nil
}

func (o *defaultLauncherSettings) SetName(name string) {
	o.name = name
}

func (o *defaultLauncherSettings) Name() string {
	return o.name
}

func (o *defaultLauncherSettings) SetExePath(filePath string) {
	o.exePath = filePath
}

func (o *defaultLauncherSettings) ExePath() string {
	return o.exePath
}

func (o *defaultLauncherSettings) ExeDirPath() string {
	return path.Dir(o.ExePath())
}

func (o *defaultLauncherSettings) SetDefaultArgs(args string) {
	o.defaultArgs = args
}

func (o *defaultLauncherSettings) DefaultArgs() string {
	return o.defaultArgs
}

func (o *defaultLauncherSettings) SetGameFileSuffixes(suffixes []string) {
	o.gameFileSuffixes = suffixes
}

func (o *defaultLauncherSettings) GameFileSuffixes() []string {
	return o.gameFileSuffixes
}

type GameSettings interface {
	SaveableSettings
	SetName(string)
	Name() string
	SetExeSubPath(string)
	ExeFullPath(launcher Launcher) (filePath string, exists bool)
	ShouldOverrideLauncherArgs() bool
	SetLauncherOverrideArgs(string)
	LauncherOverrideArgs() string
	SetAdditionalLauncherArgs(string)
	AdditionalLauncherArgs() string
	SetIconPath(string)
	IconPath() DynamicFilePath
	SetTilePath(string)
	TilePath() DynamicFilePath
	AddCategory(string)
	RemoveCategory(string)
	SetCategories([]string)
	Categories() []string
}

type defaultGameSettings struct {
	dirPath string
	config  configFile
}

func (o *defaultGameSettings) Filename(additionalSuffix string) string {
	return "game" + additionalSuffix + FileExtension
}

func (o *defaultGameSettings) Reload(filePath string) error {
	return o.config.Reload(filePath)
}

func (o *defaultGameSettings) ResetToDefaults() {
	o.config.Clear()
}

func (o *defaultGameSettings) Save(w io.Writer) error {
	return o.config.Save(w)
}

func (o *defaultGameSettings) Example() SaveableSettings {
	s := NewGameSettings("")

	s.SetName("example-game")
	s.SetAdditionalLauncherArgs("")
	s.SetLauncherOverrideArgs("")

	if runtime.GOOS == "windows" {
		s.SetExeSubPath("example.exe")
		s.SetIconPath("C:\\path\\to\\game-icon.png")
		s.SetTilePath("C:\\path\\to\\game-tile.png")
	} else {
		s.SetExeSubPath("example.sh")
		s.SetIconPath("/path/to/game-icon.png")
		s.SetTilePath("/path/to/game-tile.png")
	}

	s.SetCategories([]string{"My Cool Category", "Another Cool Category", "some-other category"})

	return s
}

func (o *defaultGameSettings) SetName(name string) {
	o.config.AddOrUpdateKeyValue(none, gameName, name)
}

func (o *defaultGameSettings) Name() string {
	name := o.config.KeyValue(none, gameName)
	if len(name) > 0 {
		return name
	}

	return path.Base(o.dirPath)
}

func (o *defaultGameSettings) SetExeSubPath(p string) {
	o.config.AddOrUpdateKeyValue(none, gameExeSubPath, appendDoubleQuotesIfNeeded(p))
}

func (o *defaultGameSettings) ExeFullPath(launcher Launcher) (string, bool) {
	exeFullPath := ""
	exeSubPath := o.config.KeyValue(none, gameExeSubPath)

	if len(strings.TrimSpace(exeSubPath)) > 0 {
		exeFullPath = filepath.Join(o.dirPath, exeSubPath)
	} else {
		found := false
		exeFullPath, found = o.defaultExeFullPath(launcher)
		if !found {
			return "", false
		}
	}

	// TODO: Does this handle Windows disk drives properly?
	exeFullPath = filepath.Clean(exeFullPath)

	_, statErr := os.Stat(exeFullPath)
	if statErr != nil {
		return exeFullPath, false
	}

	return appendDoubleQuotesIfNeeded(exeFullPath), true
}

func (o *defaultGameSettings) defaultExeFullPath(launcher Launcher) (string, bool) {
	exeFunc := func(filename string) bool {
		suffixes := launcher.GameFileSuffixes()
		for i := range suffixes {
			if strings.HasSuffix(filename, suffixes[i]) {
				return true
			}
		}

		return false
	}

	exeFilePath, found := dirContainsFile(o.dirPath, exeFunc)
	if found {
		return exeFilePath, true
	}

	return "", false
}

func (o *defaultGameSettings) ShouldOverrideLauncherArgs() bool {
	return len(o.LauncherOverrideArgs()) > 0
}

func (o *defaultGameSettings) SetLauncherOverrideArgs(args string) {
	o.config.AddOrUpdateKeyValue(none, gameOverrideArgs, args)
}

func (o *defaultGameSettings) LauncherOverrideArgs() string {
	return o.config.KeyValue(none, gameOverrideArgs)
}

func (o *defaultGameSettings) SetAdditionalLauncherArgs(args string) {
	o.config.AddOrUpdateKeyValue(none, gameAdditionalArgs, args)
}

func (o *defaultGameSettings) AdditionalLauncherArgs() string {
	return o.config.KeyValue(none, gameAdditionalArgs)
}

func (o *defaultGameSettings) SetIconPath(iconPath string) {
	o.config.AddOrUpdateKeyValue(none, gameIconPath, iconPath)
}

func (o *defaultGameSettings) IconPath() DynamicFilePath {
	return o.manualFilePathOrExisting(gameIconPath, GameIconSuffixes)
}

func (o *defaultGameSettings) SetTilePath(tilePath string) {
	o.config.AddOrUpdateKeyValue(none, gameTilePath, tilePath)
}

func (o *defaultGameSettings) TilePath() DynamicFilePath {
	return o.manualFilePathOrExisting(gameTilePath, GameTileSuffixes)
}

func (o *defaultGameSettings) manualFilePathOrExisting(k key, suffixes []string) DynamicFilePath {
	result := &defaultDynamicFilePath{
		filePath: o.config.KeyValue(none, k),
	}

	if len(strings.TrimSpace(result.filePath)) == 0 {
		result.dynamic = true
		result.filePath, result.fileExists = existingFilePath(o.dirPath, suffixes)
		if !result.fileExists {
			return result
		}
	}

	// TODO: Does this handle Windows disk drives properly?
	result.filePath = filepath.Clean(result.filePath)

	_, statErr := os.Stat(result.filePath)
	if statErr != nil {
		return result
	}

	result.fileExists = true

	return result
}

func (o *defaultGameSettings) AddCategory(c string) {
	current := o.Categories()

	for _, s := range current {
		if s == c {
			return
		}
	}

	current = append(current, c)
	o.SetCategories(current)
}

func (o *defaultGameSettings) RemoveCategory(c string) {
	current := o.Categories()

	for i, s := range current {
		if s == c {
			current = append(current[:i], current[i+1:]...)
			o.SetCategories(current)
			return
		}
	}
}

func (o *defaultGameSettings) SetCategories(cats []string) {
	o.config.AddOrUpdateKeyValue(none, gameCategories, strings.Join(cats, listSeparator))
}

func (o *defaultGameSettings) Categories() []string {
	data := o.config.KeyValue(none, gameCategories)

	if len(data) == 0 {
		return []string{}
	}

	return strings.Split(data, listSeparator)
}

type KnownGamesSettings interface {
	SaveableSettings
	GameDirPathsToGameNames() map[string]string
	AddUniqueGameOnly(game GameSettings, gameDirPath string) bool
	Disown(gameDirPath string) (gameName string, ok bool)
	DisownNonExistingGames() (gameDirPathsToGameNames map[string]string)
}

type defaultKnownGamesSettings struct {
	mutex    *sync.Mutex
	config   configFile
	filePath string
}

func (o *defaultKnownGamesSettings) Filename(additionalSuffix string) string {
	return ".known-games" + additionalSuffix + FileExtension
}

func (o *defaultKnownGamesSettings) Reload(filePath string) error {
	return o.config.Reload(filePath)
}

func (o *defaultKnownGamesSettings) ResetToDefaults() {
	o.mutex.Lock()
	defer o.mutex.Unlock()

	o.config.Clear()
	o.config.SetSectionComment(none, managedFileComment)
}

func (o *defaultKnownGamesSettings) Save(w io.Writer) error {
	o.mutex.Lock()
	defer o.mutex.Unlock()

	o.config.SetSectionComment(none, managedFileComment)

	return o.config.Save(w)
}

func (o *defaultKnownGamesSettings) Example() SaveableSettings {
	return &defaultKnownGamesSettings{}
}

func (o *defaultKnownGamesSettings) GameDirPathsToGameNames() map[string]string {
	o.mutex.Lock()
	defer o.mutex.Unlock()

	return o.config.SectionKeysToValues(none)
}

func (o *defaultKnownGamesSettings) AddUniqueGameOnly(game GameSettings, dirPath string) bool {
	o.mutex.Lock()
	defer o.mutex.Unlock()

	var count int

	for _, gameName := range o.config.SectionValues(none) {
		if gameName == game.Name() {
			count++

			// TODO: Why did I do this again?
			if count > 1 {
				return false
			}
		}
	}

	o.config.AddOrUpdateKeyValue(none, key(dirPath), game.Name())
	o.saveUnsafe()

	return true
}

func (o *defaultKnownGamesSettings) Disown(dirPath string) (string, bool) {
	o.mutex.Lock()
	defer o.mutex.Unlock()

	return o.disownUnsafe(dirPath)
}

func (o *defaultKnownGamesSettings) DisownNonExistingGames() map[string]string {
	o.mutex.Lock()
	defer o.mutex.Unlock()

	disownedDirPathsToGameNames := make(map[string]string)

	for _, dirPath := range o.config.SectionKeys(none) {
		_, statErr := os.Stat(dirPath)
		if statErr == nil {
			continue
		}

		name, ok := o.disownUnsafe(dirPath)
		if ok {
			disownedDirPathsToGameNames[dirPath] = name
		}
	}

	return disownedDirPathsToGameNames
}

func (o *defaultKnownGamesSettings) disownUnsafe(dirPath string) (string, bool) {
	if o.config.HasKey(none, key(dirPath)) {
		gameName := o.config.KeyValue(none, key(dirPath))
		o.config.DeleteKey(none, key(dirPath))
		o.saveUnsafe()

		return gameName, true
	}

	return "", false
}

func (o *defaultKnownGamesSettings) saveUnsafe() error {
	f, err := os.OpenFile(o.filePath, os.O_WRONLY|os.O_CREATE, defaultFileMode)
	if err != nil {
		return err
	}
	defer f.Close()

	err = f.Truncate(0)
	if err != nil {
		return err
	}

	err = o.config.Save(f)
	if err != nil {
		return err
	}

	return nil
}

func NewAppSettings() AppSettings {
	s := &defaultAppSettings{
		config: newEmptyIniFile(),
	}

	s.ResetToDefaults()

	return s
}

func NewLaunchersSettings() LaunchersSettings {
	s := &defaultLaunchersSettings{
		config: newEmptyIniFile(),
	}

	s.ResetToDefaults()

	return s
}

func NewLauncher() Launcher {
	s := &defaultLauncherSettings{}

	s.ResetToDefaults()

	return s
}

func NewGameSettings(dirPath string) GameSettings {
	s := &defaultGameSettings{
		dirPath: dirPath,
		config:  newEmptyIniFile(),
	}

	s.ResetToDefaults()

	return s
}

func LoadOrCreateKnownGamesSettings(parentDirPath string) (KnownGamesSettings, bool) {
	s := &defaultKnownGamesSettings{
		config: newEmptyIniFile(),
		mutex:  &sync.Mutex{},
	}

	s.ResetToDefaults()

	s.filePath = path.Join(parentDirPath, s.Filename(""))

	f, err := loadIniConfigFile(s.filePath)
	if err != nil {
		s.saveUnsafe()

		return s, false
	}

	s.config = f

	return s, true
}

func LoadGameSettings(filePath string, launcher Launcher) (GameSettings, error) {
	f, err := loadIniConfigFile(filePath)
	if err != nil {
		return &defaultGameSettings{}, err
	}

	d := &defaultGameSettings{
		config:  f,
		dirPath: path.Dir(filePath),
	}

	_, exeExists := d.ExeFullPath(launcher)
	if !exeExists {
		return &defaultGameSettings{}, errors.New("The game config's executable path does not exist")
	}

	return d, nil
}

func existingFilePath(dirPath string, suffixes []string) (string, bool) {
	matchFunc := func(filename string) bool {
		for i := range suffixes {
			if strings.HasSuffix(filename, suffixes[i]) {
				return true
			}
		}

		return false
	}

	filePath, found := dirContainsFile(dirPath, matchFunc)
	if found {
		return filePath, true
	}

	return "", false
}

func dirContainsFile(dirPath string, fileNameMatchFunc func(string) bool) (string, bool) {
	dirInfos, err := ioutil.ReadDir(dirPath)
	if err != nil {
		return "", false
	}

	for i := range dirInfos {
		if dirInfos[i].IsDir() {
			continue
		}

		if fileNameMatchFunc(dirInfos[i].Name()) {
			return path.Join(dirPath, dirInfos[i].Name()), true
		}
	}

	return "", false
}

func Create(parentDirPath string, filenameSuffix string, s SaveableSettings) error {
	err := CreateDir(parentDirPath)
	if err != nil {
		return err
	}

	filePath := path.Join(parentDirPath, s.Filename(filenameSuffix))

	f, err := os.OpenFile(filePath, os.O_TRUNC|os.O_CREATE|os.O_WRONLY, defaultFileMode)
	if err != nil {
		return err
	}

	err = s.Save(f)
	if err != nil {
		return err
	}
	defer f.Close()

	return nil
}

func appendDoubleQuotesIfNeeded(s string) string {
	if strings.Contains(s, " ") {
		doubleQuote := "\""

		if !strings.HasPrefix(s, doubleQuote) {
			s = doubleQuote + s
		}

		if !strings.HasSuffix(s, doubleQuote) {
			s = s + doubleQuote
		}
	}

	return s
}
